/*//////////////////////////////////////////////////////////////////
////     The SKIRT project -- advanced radiative transfer       ////
////       Â© Astronomical Observatory, Ghent University         ////
///////////////////////////////////////////////////////////////// */

#ifndef ITEMINFO_HPP
#define ITEMINFO_HPP

#include "Item.hpp"
#include "ItemRegistry.hpp"
#include "PropertyAccessor.hpp"

////////////////////////////////////////////////////////////////////

/** \file
    \brief The ItemInfo macros

    The ItemInfo macros provided in this header file are used in the C++ class definition of a
    client Item subclass to declare metadata for the class and for its discoverable properties.
    Assuming that all Item subclasses in a given inheritance tree properly use these macros to
    declare their discoverable properties, a SMILE schema definition can be derived from the
    metadata generated by the macros. This schema definition can then be used to save and restore a
    hierarchy of client items to and from a SMILE data set in XML format. Alternatively, the schema
    definition itself can be saved to an XML representation for use in a generic SMILE tool as
    described above. Refer to the documentation of the Item class for more information on client
    items and their use.

    <B><I> Using the ItemInfo macros </I></B>

    The C++ class definition of each client Item subclass must declare metadata for the class and
    for its discoverable properties (if there are any) through the macros provided here.
    There are macros to declare four kinds of objects:

    - The ITEM macros declare the item defined by the subclass in which they reside,
      including the immediate base class and a human readable description.
    - The PROPERTY macros declare a discoverable property of the item, including
      the property name and type and a human readable description.
    - The ATTRIBUTE macros declare an attribute of the item or of the most recently
      declared property, such as for example a default value.
    - The ENUM macros declare an enumeration type that can be used as the type for
      a discoverable property.

    Each PROPERTY macro generates the following items in the class definition:
    - A private data member declaration for the property, using the property name with an
      underscore prefix. This data member can be read and written in the class implementation;
      however it is recommended to treat the data member read-only, except in very rare cases.
    - A public getter for the property value, using the property name. This getter can be
      freely used inside and outside the class implementation.
    - A brief Doxygen comment block for the getter, including the human readable string
      provided as a macro argument. To provide additional documentation for a property,
      place an appropriate Doxygen comment block after the ItemInfo macros as shown below.
    - A private setter with an undocumented name used by the SMILE library to initialize
      the property value when constructing a new SMILE item hierarchy. The SMILE library
      guarantees that the property value after construction conforms to the requirements listed
      in the SMILE schema (such as range limits and default values). The private scope helps
      ensure that this guarantee is not inadvertently broken by client code.
      If a public or protected setter is absolutely required, it can be seperately provided.
    - A private and undocumented function to load the metadata used by the SMILE library
      when deriving a SMILE schema for this client Item class hierarchy.

    The ItemInfo macro invocations must be placed at the top of the class definition.
    If any of the discoverable properties use an enumeration type, these types must be declared
    first. It is not possible to use an enumeration type declared in another class or scope.
    For each enumeration type, the declaration sequence is as follows:
    - A regular Doxygen comment block documenting the enumeration type
    - The ENUM_DEF macro
    - One or more ENUM_VAL macros
    - The ENUM_END macro

    The item, property, and attribute declarations are placed after any enumeration type
    declarations, in the following order:
    - The ITEM_ABSTRACT or ITEM_CONCRETE macro followed by zero or more
      ATTRIBUTE macros that apply to this item
    - Zero or more property blocks, each consisting of a PROPERTY macro followed by
      zero or more ATTRIBUTE macros that apply to this property
    - The ITEM_END macro

    It is not allowed to place other C++ statements between the ItemInfo macros.
    Also, it is not allowed to place Doxygen comment blocks between the ItemInfo macros,
    other than comment blocks documenting an enumeration type as mentioned above.
    To provide additional documentation for a property, place a Doxygen comment block after
    the last ItemInfo macro with an explicit reference to the documented property as shown
    in the example below.

    <B><I> Conditionals </I></B>

    The SMILE system supports dynamically adjusting displayed options and default values to choices
    made earlier in the configuration process. These earlier choices may represent various aspects
    of the configuration, including the level of expertise selected by the user, some overall mode
    configured early on, or the value of the option just preceding this one.

    When processing a SMILE dataset, the system maintains two sets of names with a different scope.
    The global set contains names that stay around for the duration of the configuration session.
    The local set contains names that stay around only while considering the properties of a
    particular type; a fresh local set is created for each type instance. By definition, the global
    set contains names that start with an uppercase letter, and the local set contains names that
    start with a lowercase letter. As a result, the two sets form disjoint namespaces. After the
    first character (which must be a letter), a name can include any mix of letters and digits (and
    no other characters).

    Names are never removed from a set (although the current local set is regularly discarded and
    replaced by a new one as a whole). Names are inserted in each of these sets as the dataset gets
    processed according to the rules set forth by the SMILE specification. Boolean expressions and
    conditional value expressions can then be evaluated as they occur in type and property
    attributes, replacing names contained in one of the sets by true, and other names by false.

    <B><I> Example </I></B>

    \verbatim
    class ColorDecorator : public ShapeDecorator
    {
        /// This enumeration lists the supported colors. Select 'Custom' to allow
        /// specifying arbitrary red, green, and blue intensities.
        ENUM_DEF(Color, White, Red, Green, Blue, Custom)
        ENUM_VAL(Color, White, "the white color")
        ENUM_VAL(Color, Red, "the red color")
        ENUM_VAL(Color, Green, "the green color")
        ENUM_VAL(Color, Blue, "the blue color")
        ENUM_VAL(Color, Custom, "a custom RGB color")
        ENUM_END()

        ITEM_CONCRETE(ColorDecorator, ShapeDecorator, "a decorator that sets the color of a shape")
        PROPERTY_ENUM(color, Color, "the color of the decorated shape")
        PROPERTY_DOUBLE_LIST(rgb, "the red, green, blue intensities of the decorated shape")
        ATTRIBUTE_RELEVANT_IF(rgb, "colorCustom")
        ITEM_END()

        /// \fn rgb
        /// This is extra documentation for the \em rgb property.
        ...
    };
    \endverbatim

    <B><I> Configuring Doxygen for the ItemInfo macros </I></B>

    To properly document the functions generated by the ItemInfo macros, set the following tags
    in the Doxygen configuration file:

    \verbatim
    EXCLUDE_SYMBOLS  = ii_*
    MACRO_EXPANSION  = YES
    INCLUDE_PATH     = schema
    ALIASES          = function{1}="\fn \1 \n"
    \endverbatim

    The first setting causes the private and undocumented "item info" functions to be excluded from
    the Doxygen output. The second setting causes Doxygen to parse the source code expansion of
    macros looking for comment blocks. This allows the macros provided here to automatically
    document the getters for discoverable properties. The include path should be set to the
    directory containing the ItemInfo.hpp file. The \em function alias is defined to allow
    terminating the \em fn command argument with a newline character without actually placing the
    remaining text in the comment block on the next line. This is used by the Doxygen documentation
    blocks inside the macro definitions, because the Doxygen preprocessor always places the
    complete contents of a macro expansion on a single line.
*/

// Disable auto-formatting because scope blocks are split over multiple macro definitions, confusing the algorithm
// clang-format off

// ================== ENUMERATIONS ==================

/** This macro declares a scoped enumeration type (\c enum \c class) that can be used as the data
    type of a discoverable property. The first argument specifies the enumeration type name (as an
    identifier). The subsequent arguments (there must be at least one) specify the enumeration
    values (as identifiers) for the type. The ENUM_DEF invocation must be followed by an ENUM_VAL
    invocation for each of the enumeration values in the list, in the same order, and by an
    ENUM_END invocation to terminate the sequence. */
#define ENUM_DEF(enumtype, ...) \
public: \
    enum class enumtype : int { __VA_ARGS__ }; \
private: \
    static void ii_loadEnumInfo_##enumtype() \
    { \
        enum enumtype##_private : int { __VA_ARGS__ }; \
        const int enumIndices[] = { __VA_ARGS__ }; \
        ItemRegistry::beginEnum(static_cast<int>(sizeof(enumIndices)/sizeof(int)));

/** This macro declares one of the values of an enumeration type declared with the ENUM_DEF macro.
    The first argument repeats the enumeration type name (as an identifier). The second argument
    specifies the enumeration value being declared by this macro invocation (as an identifier). The
    third argument provides a human readable description for the enumeration value (as a quoted
    string). */
#define ENUM_VAL(enumtype, enumvalue, title) \
        ii_loadEnumInfo_##enumtype##_##enumvalue(); \
    } \
    /** \enum enumtype enumvalue : title. */ \
    static void ii_loadEnumInfo_##enumtype##_##enumvalue() \
    { \
        ItemRegistry::addEnum(static_cast<int>(enumtype::enumvalue), #enumvalue, title);

/** This macro marks the end of the sequence started by an ENUM_DEF invocation to declare an
    enumeration type. */
#define ENUM_END() \
        ItemRegistry::endEnum(); \
    }

// ================== ITEMS ==================

/** This macro starts the ItemInfo metadata section for an abstract SMILE item type. An abstract
    type serves as the base type for other types. It is impossible to construct an instance of an
    abstract type. The first argument specifies the name of the class in which this macro
    invocation occurs (as an identifier). The class name corresponds to the type name of the SMILE
    items represented by the class. The second argument specifies the name of the immediate base
    class of this class (as an identifier). The third argument provides a human readable
    description for items of this type (as a quoted string). */
#define ITEM_ABSTRACT(itemtype, basetype, title) \
protected: \
    /** Default constructor for abstract Item subclass itemtype: title. */ \
    itemtype() {} \
private: \
    friend class ItemRegistry; \
    using ItemType = itemtype; \
    using BaseType = basetype; \
    const char* ii_type() const override { return #itemtype; } \
    static void ii_loadItemInfo() \
    { \
        ItemRegistry::beginType(#itemtype, #basetype, title);

/** This macro starts the ItemInfo metadata section for a concrete SMILE item type. In other words,
    actual item instances of this type can be constructed. On rare occasions, a concrete type can
    also serve as the base type for another concrete type. The first argument specifies the name of
    the class in which this macro invocation occurs (as an identifier). The class name corresponds
    to the type name of the SMILE items represented by the class. The second argument specifies the
    name of the immediate base class of this class (as an identifier). The third argument provides
    a human readable description for items of this type (as a quoted string). */
#define ITEM_CONCRETE(itemtype, basetype, title) \
protected: \
    /** Default constructor for concrete Item subclass itemtype: title. */ \
    itemtype() {} \
private: \
    friend class ItemRegistry; \
    using ItemType = itemtype; \
    using BaseType = basetype; \
    static Item* ii_createItem() { return new ItemType; } \
    const char* ii_type() const override { return #itemtype; } \
    static void ii_loadItemInfo() \
    { \
        ItemRegistry::beginType(#itemtype, #basetype, title, ii_createItem);

/** This macro marks the end of the ItemInfo metadata section. */
#define ITEM_END() \
    }

// ================== PROPERTIES ==================

/** This macro declares a string property. The first argument specifies the name of the property
    (as an identifier). The second argument provides a human readable description for this property
    (as a quoted string). */
#define PROPERTY_STRING(propname, title) \
        ii_loadItemInfo_##propname(); \
    } \
    string _##propname; \
    void  ii_set_##propname(string value) { _##propname = value; } \
public: \
    /** This function returns the value of the discoverable string property \em propname: title. */ \
    string propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("StringProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<string, ItemType>(&ItemType::propname, &ItemType::ii_set_##propname));

/** This macro declares a Boolean property. The first argument specifies the name of the property
    (as an identifier). The second argument provides a human readable description for this property
    (as a quoted string). */
#define PROPERTY_BOOL(propname, title) \
        ii_loadItemInfo_##propname(); \
    } \
    bool _##propname{0}; \
    void  ii_set_##propname(bool value) { _##propname = value; } \
public: \
    /** This function returns the value of the discoverable Boolean property \em propname: title. */ \
    bool propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("BoolProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<bool, ItemType>(&ItemType::propname, &ItemType::ii_set_##propname));

/** This macro declares an integer property. The first argument specifies the name of the property
    (as an identifier). The second argument provides a human readable description for this property
    (as a quoted string). */
#define PROPERTY_INT(propname, title) \
        ii_loadItemInfo_##propname(); \
    } \
    int _##propname{0}; \
    void  ii_set_##propname(int value) { _##propname = value; } \
public: \
    /** This function returns the value of the discoverable integer property \em propname: title. */ \
    int propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("IntProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<int, ItemType>(&ItemType::propname, &ItemType::ii_set_##propname));

/** This macro declares an enumeration property. The first argument specifies the name of the
    property (as an identifier). The second argument specifies the name of the enumeration type (as
    an identifier). The third argument provides a human readable description for this property (as
    a quoted string). */
#define PROPERTY_ENUM(propname, enumtype, title) \
        ii_loadItemInfo_##propname(); \
    } \
    enumtype _##propname{}; \
    void  ii_set_##propname(enumtype value) { _##propname = value; } \
public: \
    /** This function returns the value of the discoverable enumtype enumeration property \em propname: title. */ \
    enumtype propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("EnumProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<enumtype, ItemType>(&ItemType::propname, &ItemType::ii_set_##propname)); \
        ii_loadEnumInfo_##enumtype();

/** This macro declares a double property (floating point value). The first argument specifies the
    name of the property (as an identifier). The second argument provides a human readable
    description for this property (as a quoted string). */
#define PROPERTY_DOUBLE(propname, title) \
        ii_loadItemInfo_##propname(); \
    } \
    double _##propname{0.}; \
    void  ii_set_##propname(double value) { _##propname = value; } \
public: \
    /** This function returns the value of the discoverable double property \em propname: title. */ \
    double propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("DoubleProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<double, ItemType>(&ItemType::propname, &ItemType::ii_set_##propname));

/** This macro declares a double list property (list of floating point values). The first argument
    specifies the name of the property (as an identifier). The second argument provides a human
    readable description for this property (as a quoted string). */
#define PROPERTY_DOUBLE_LIST(propname, title) \
        ii_loadItemInfo_##propname(); \
    } \
    vector<double> _##propname; \
    void  ii_set_##propname(vector<double> value) { _##propname = value; } \
public: \
    /** This function returns the value of the discoverable double list property \em propname: title. */ \
    const vector<double>& propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("DoubleListProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<vector<double>, ItemType>(&ItemType::propname, &ItemType::ii_set_##propname));

/** This macro declares an item property (aggregating pointer to another item). The first argument
    specifies the name of the property (as an identifier). The second argument specifies the type
    name of the item being held by this property (as an identifier). The third argument provides a
    human readable description for this property (as a quoted string). */
#define PROPERTY_ITEM(propname, itemtype, title) \
        ii_loadItemInfo_##propname(); \
    } \
    itemtype* _##propname{nullptr}; \
    void  ii_set_##propname(itemtype* value) {destroyChild(_##propname); _##propname = value; addChild(_##propname);} \
public: \
    /** This function returns the value of the discoverable item property \em propname: title. */ \
    itemtype* propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("ItemProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<itemtype*, ItemType>(&ItemType::propname, &ItemType::ii_set_##propname)); \
        ItemRegistry::setBase(#itemtype);

/** This macro declares an item list property (list of aggregating pointers to another item). The
    first argument specifies the name of the property (as an identifier). The second argument
    specifies the type name of the items being held by this property (as an identifier). The third
    argument provides a human readable description for this property (as a quoted string). */
#define PROPERTY_ITEM_LIST(propname, itemtype, title) \
        ii_loadItemInfo_##propname(); \
    } \
    vector<itemtype*> _##propname; \
    void  ii_clear_##propname() \
    {  \
        for (auto it : _##propname) destroyChild(it); \
        _##propname.clear(); \
    } \
    void  ii_insert_##propname(int index, itemtype* value) \
    { \
        if (index >= 0 && static_cast<size_t>(index) < _##propname.size()) \
            _##propname.insert(_##propname.cbegin()+index, value); \
        else \
            _##propname.push_back(value); \
        addChild(value); \
    } \
    void  ii_remove_##propname(int index) \
    { \
        if (index >= 0 && static_cast<size_t>(index) < _##propname.size()) \
        { \
            destroyChild(_##propname[index]); \
            _##propname.erase(_##propname.cbegin()+index, _##propname.cbegin()+index+1); \
        } \
    } \
public: \
    /** This function returns the value of the discoverable item list property \em propname: title. */ \
    const vector<itemtype*>& propname() const { return _##propname; } \
private: \
    static void ii_loadItemInfo_##propname() \
    { \
        ItemRegistry::beginProperty("ItemListProperty", #propname, title,  \
            new TargetTypedPropertyAccessor<vector<itemtype*>, ItemType>(&ItemType::propname, \
                &ItemType::ii_clear_##propname, &ItemType::ii_insert_##propname, &ItemType::ii_remove_##propname)); \
        ItemRegistry::setBase(#itemtype);

// ================== TYPE ATTRIBUTES ==================

/** This macro sets the \em allowedIf attribute for the item type being declared. The first
    argument repeats the type name. The second argument specifies the Boolean expression to be set
    as the \em allowedIf attribute value (as a quoted string). The values of \em allowedIf
    attributes for all direct and indirect base types of this type are ANDed with this value. The
    final value (after evaluation against the names in the current global and local name sets)
    indicates whether this type is allowed in that dataset. */
#define ATTRIBUTE_TYPE_ALLOWED_IF(itemtype, boolexpr) \
        ii_loadItemInfo_allowedIf(); \
    } \
    /** \class itemtype itemtype itemtype This item type is allowed only if the Boolean expression boolexpr
        evaluates to true after replacing the names by true or false depending on their presence. */ \
private: \
    static void ii_loadItemInfo_allowedIf() \
    { \
        ItemRegistry::setTypeAllowedIf(boolexpr);

/** This macro sets the \em displayedIf attribute for the item type being declared. The first
    argument repeats the type name. The second argument specifies the Boolean expression to be set
    as the \em displayedIf attribute value (as a quoted string). The values of \em displayedIf
    attributes for all direct and indirect base types of this type are ANDed with this value. The
    final value (after evaluation against the names in the current global and local name sets)
    indicates whether this type is displayed as one of the choices. */
#define ATTRIBUTE_TYPE_DISPLAYED_IF(itemtype, boolexpr) \
        ii_loadItemInfo_displayedIf(); \
    } \
    /** \class itemtype itemtype itemtype This item type is displayed only if the Boolean expression boolexpr
        evaluates to true after replacing the names by true or false depending on their presence. */ \
private: \
    static void ii_loadItemInfo_displayedIf() \
    { \
        ItemRegistry::setTypeDisplayedIf(boolexpr);

/** This macro sets the \em insert attribute for the item type being declared. The first argument
    repeats the type name. The second argument specifies the conditional value expression to be set
    as the \em insert attribute value (as a quoted string). The value of the expression (after
    evaluation against the names in the current global and local name sets) provides a list of
    extra names to be inserted in the global and/or local name set when an item of this type is
    added to the dataset, in addition to the names of the type and its ancestors. */
#define ATTRIBUTE_TYPE_INSERT(itemtype, valexpr) \
        ii_loadItemInfo_insert(); \
    } \
    /** \class itemtype itemtype itemtype When an item of this type is used, the names provided by
        the conditional value expression valexpr are inserted into the name sets used for
        evaluating Boolean expressions. */ \
private: \
    static void ii_loadItemInfo_insert() \
    { \
        ItemRegistry::setTypeInsert(valexpr);

/** This macro sets the \em subPropertyIndex attribute for the item type being declared to a value
    depending on the position of the macro in the list of property definitions. As a result,
    properties of subtypes will be listed at the position where the macro appears. If the macro
    does not occur, by default properties of subtypes are listed after all properties of the base
    type. The macro's first and only argument repeats the type name. */
#define ATTRIBUTE_SUB_PROPERTIES_HERE(itemtype) \
        ii_loadItemInfo_subPropertiesHere(); \
    } \
    /** \class itemtype itemtype itemtype Properties of sub-types of this type are listed in user
        interfaces somewhere in between the properties of this type. */ \
private: \
    static void ii_loadItemInfo_subPropertiesHere() \
    { \
        ItemRegistry::setSubPropertyIndexHere();

// ================== PROPERTY ATTRIBUTES ==================

/** This macro sets the \em relevantIf attribute for the most recently declared property. The first
    argument repeats the property name (as an identifier). The second argument specifies the
    Boolean expression to be set as the \em relevantIf attribute value (as a quoted string). In
    other words, the property will be relevant only if the specified Boolean expression evaluates
    to true against the names in the current global and local name sets. */
#define ATTRIBUTE_RELEVANT_IF(propname, boolexpr) \
        ii_loadItemInfo_##propname##_relevantIf(); \
    } \
    /** \function{propname()} This property is relevant only if the Boolean expression boolexpr evaluates to true
        after replacing the names by true or false depending on their presence. */ \
private: \
    static void ii_loadItemInfo_##propname##_relevantIf() \
    { \
        ItemRegistry::setRelevantIf(boolexpr);

/** This macro sets the \em displayedIf attribute for the most recently declared property. The first
    argument repeats the property name (as an identifier). The second argument specifies the
    Boolean expression to be set as the \em displayedIf attribute value (as a quoted string). In
    other words, the property will be displayed only if the specified Boolean expression evaluates
    to true against the names in the current global and local name sets. */
#define ATTRIBUTE_DISPLAYED_IF(propname, boolexpr) \
        ii_loadItemInfo_##propname##_displayedIf(); \
    } \
    /** \function{propname()} This property is displayed only if the Boolean expression boolexpr evaluates to true
        after replacing the names by true or false depending on their presence. */ \
private: \
    static void ii_loadItemInfo_##propname##_displayedIf() \
    { \
        ItemRegistry::setDisplayedIf(boolexpr);

/** This macro sets the \em requiredIf attribute for the most recently declared property. The first
    argument repeats the property name (as an identifier). The second argument specifies the
    Boolean expression to be set as the \em requiredIf attribute value (as a quoted string). In
    other words, the property is required if the specified Boolean expression evaluates
    to true against the names in the current global and local name sets, and optional otherwise. */
#define ATTRIBUTE_REQUIRED_IF(propname, boolexpr) \
        ii_loadItemInfo_##propname##_requiredIf(); \
    } \
    /** \function{propname()} This property is required only if the Boolean expression boolexpr evaluates to true
        after replacing the names by true or false depending on their presence. */ \
private: \
    static void ii_loadItemInfo_##propname##_requiredIf() \
    { \
        ItemRegistry::setRequiredIf(boolexpr);

/** This macro sets the \em insert attribute for the most recently declared property. The first
    argument repeats the property name (as an identifier). The second argument specifies the
    conditional value expression to be set as the \em insert attribute value (as a quoted string).
    The value of the expression (after evaluation against the names in the current global and local
    name sets) provides a list of extra names to be inserted in the global and/or local name set
    when a value is entered for this property, in addition to the name automatically associated
    with the property. */
#define ATTRIBUTE_INSERT(propname, valexpr) \
        ii_loadItemInfo_##propname##_insert(); \
    } \
    /** \function{propname()} When a value is entered for this property, the names provided by the
        conditional value expression valexpr are inserted into the name sets used for evaluating
        Boolean expressions. */ \
private: \
    static void ii_loadItemInfo_##propname##_insert() \
    { \
        ItemRegistry::setInsert(valexpr);

/** This macro sets the default value for the most recently declared property. The first argument
    repeats the property name (as an identifier). The second argument specifies the default value
    (as a quoted string) in the form of a conditional value expression, which is evaluated against
    the names in the current global and local name sets. Each value in the conditional expression
    must have a format that can be properly converted to the property data type. */
#define ATTRIBUTE_DEFAULT_VALUE(propname, valexpr) \
        ii_loadItemInfo_##propname##_defaultValue(); \
    } \
    /** \function{propname()} The default value for this property is given by the conditional value
        expression valexpr. */ \
private: \
    static void ii_loadItemInfo_##propname##_defaultValue() \
    { \
        ItemRegistry::setDefaultValue(valexpr);

/** This macro sets the minimum value for the most recently declared property. The first argument
    repeats the property name (as an identifier). The second argument specifies the minimum value
    (as a quoted string) in a format that can be properly converted to the property data type. */
#define ATTRIBUTE_MIN_VALUE(propname, valstring) \
        ii_loadItemInfo_##propname##_minValue(); \
    } \
    /** \function{propname()} The minimum value for this property is valstring. */ \
private: \
    static void ii_loadItemInfo_##propname##_minValue() \
    { \
        ItemRegistry::setMinValue(valstring);

/** This macro sets the maximum value for the most recently declared property. The first argument
    repeats the property name (as an identifier). The second argument specifies the maximum value
    (as a quoted string) in a format that can be properly converted to the property data type. */
#define ATTRIBUTE_MAX_VALUE(propname, valstring) \
        ii_loadItemInfo_##propname##_maxValue(); \
    } \
    /** \function{propname()} The maximum value for this property is valstring. */ \
private: \
    static void ii_loadItemInfo_##propname##_maxValue() \
    { \
        ItemRegistry::setMaxValue(valstring);

/** This macro sets the name of the physical quantity represented by this double or double list
    property. The first argument repeats the property name (as an identifier). The second argument
    specifies the quantity name (as a quoted string). The specified quantity name must match one of
    the quantity names provided in the schema definition and determines the allowed and default
    units for the property values. Refer to the documentation of the UnitDef and ItemRegistry
    classes for more information. If the specified string is empty, or if this attribute is
    omitted, the property values are dimensionless. */
#define ATTRIBUTE_QUANTITY(propname, quantityname) \
        ii_loadItemInfo_##propname##_quantity(); \
    } \
    /** \function{propname()} This property represents a physical quantity of type quantityname. */ \
private: \
    static void ii_loadItemInfo_##propname##_quantity() \
    { \
        ItemRegistry::setQuantity(quantityname);

////////////////////////////////////////////////////////////////////

#endif
