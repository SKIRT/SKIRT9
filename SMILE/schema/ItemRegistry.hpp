/*//////////////////////////////////////////////////////////////////
////     The SKIRT project -- advanced radiative transfer       ////
////       Â© Astronomical Observatory, Ghent University         ////
///////////////////////////////////////////////////////////////// */

#ifndef ITEMREGISTRY_HPP
#define ITEMREGISTRY_HPP

#include "Basics.hpp"
class Item;
class PropertyAccessor;
class SchemaDef;
class UnitDef;

////////////////////////////////////////////////////////////////////

/** The ItemRegistry class offers a set of static functions that manage the global registry of Item
    subclasses in the program. The functions are grouped in three interfaces with distinct goals:
     - Adding a schema definition and the corresponding Item subclasses to the register; this
       interface should be invoked during program startup, before any multi-threading occurs,
       and at program termination, after all use of the registry has finished.
     - Loading the metadata about discoverable properties for each of those classes into the register;
       this interface is called from the functions generated by the metadata macros in Item subclasses,
       and is indirectly invoked from the first interface when a class is added to the registry.
     - Obtaining a schema definition for use with any of the SMILE features; this interface can be
       called at any time after the registry has been completed, i.e. after program setup.

    The first two interfaces set up the global data structures representing the item registry.
    They are \em not thread-safe and may be called only during program startup and termination
    from a single thread. The third interface does not modify the global data structures,
    and is thus fully thread-safe.
*/
class ItemRegistry final
{
public:
    // ================== Adding a schema definition and Item subclasses ==================

    /** This function creates a new, empty SMILE schema definition and initializes its basic
        properties as specified by the function arguments. The new schema definition becomes the
        \em target for any subsequent calls to the add() function. The function arguments specify,
        in order of occurrence:
        - \em name: a short name for this schema
        - \em title: a description of the type of datasets described by this schema
        - \em version: the version of this schema definition
        - \em extension: the filename extension for datasets described by this schema
        - \em root: the name of the root element in datasets described by this schema
        - \em type: the type of the top-level item in datasets described by this schema
        - \em format: the version of the described data format (specified on the root element)
        - \em url: a URL pointing to information on the Web for this schema (or the empty string if not available)

        This function is \em not thread-safe and may be called only during program startup
        from a single thread. */
    static void beginSchema(string name, string title, string version, string extension, string root, string type,
                            string format, string url);

    /** This function adds the Item subclass specified as template argument to the current \em
        target schema definition in the registry. The function causes the metadata about
        discoverable properties for the specified class to be loaded into the schema definition.
        This function is \em not thread-safe and may be called only during program startup from a
        single thread. */
    template<class ItemClass> static void add()
    {
        static_assert(std::is_base_of<typename ItemClass::BaseType, typename ItemClass::ItemType>::value,
                      "Item subclass does not inherit its advertised base class");
        static_assert(std::is_base_of<Item, typename ItemClass::BaseType>::value,
                      "Item base class does not inherit Item");
        ItemClass::ii_loadItemInfo();
    }

    /** This function adds the unit and unit system information loaded by the UnitDef subclass
        specified as template argument to the current \em target schema definition in the registry.
        This function is \em not thread-safe and may be called only during program startup from a
        single thread. */
    template<class UnitDefClass> static void addUnitDef()
    {
        UnitDefClass def;
        addUnitDefImpl(def);
    }

private:
    /** This private function adds the unit and unit system information held by the specified
        UnitDef subclass instance to the current \em target schema definition in the registry. This
        function is \em not thread-safe and may be called only during program startup from a single
        thread. */
    static void addUnitDefImpl(const UnitDef& unitDef);

public:
    /** This function releases the global memory structure representing the registry. This function
        is \em not thread-safe; it should be invoked at least once at program termination, after
        closing down any parallel threads and after the last use of the facilities offered by this
        class. */
    static void finalize();

    // ================== Loading metadata about discoverable properties ==================

    /** Type definition for a function that creates an instance of an Item subclass. */
    using Instantiator = Item* (*)();

    /** This function creates a new type definition and initializes its basic properties as
        specified by the function arguments. The new type definition becomes the \em target for
        subsequent calls to the registry. */
    static void beginType(const char* type, const char* baseType, const char* title,
                          Instantiator instantiator = nullptr);

    /** This function sets the value of the 'allowedIf' attribute of the current target type,
        i.e. a Boolean expression using names inserted elsewhere in this schema definition. */
    static void setTypeAllowedIf(const char* expression);

    /** This function sets the value of the 'displayedIf' attribute of the current target type,
        i.e. a Boolean expression using names inserted elsewhere in this schema definition. */
    static void setTypeDisplayedIf(const char* expression);

    /** This function sets the value of the 'insert' attribute of the current target type,
        i.e. a conditional value expression providing names inserted when the type is used. */
    static void setTypeInsert(const char* expression);

    /** This function sets the index in the property list where properties of subtypes should be
        listed to the number of properties currently held by the target type definition. This has
        the effect of listing properties of subtypes just before the next property added to the
        type definition (or at the end if no further properties are added). */
    static void setSubPropertyIndexHere();

    /** This function creates a new property definition and initializes its basic properties as
        specified by the function arguments. The new property definition becomes the \em target for
        subsequent calls to the registry. */
    static void beginProperty(const char* type, const char* name, const char* title, const PropertyAccessor* accessor);

    /** This function begins the addition of enumeration information to the current target
        property. The argument specifies the number of elements in the enumeration type. If this
        number is zero or negative, a fatal error is thrown. An invocation of this function must be
        followed by one or more calls of the addEnum() function and a single call of the endEnum()
        function. */
    static void beginEnum(int enumCount);

    /** This function adds information for one enumeration element to the current target property.
        Enumeration elements must be added in the order of their definition in the enumeration
        type. If the invocations does not adhere to this pattern, a fatal error is thrown. The
        arguments specify the enumeration index (i.e. the integer value underlying the enumeration
        element), a string version of the enumeration element's identifier, and a user-oriented
        description of the enumeration element. */
    static void addEnum(int enumIndex, const char* enumName, const char* enumTitle);

    /** This function verifies that all enumeration elements for the enumeration type started by a
        call to beginEnum() have been added. */
    static void endEnum();

    /** This function sets the value of the 'relevantIf' attribute of the current target property,
        i.e. a Boolean expression using names inserted elsewhere in this schema definition. */
    static void setRelevantIf(const char* expression);

    /** This function sets the value of the 'displayedIf' attribute of the current target property,
        i.e. a Boolean expression using names inserted elsewhere in this schema definition. */
    static void setDisplayedIf(const char* expression);

    /** This function sets the value of the 'requiredIf' attribute of the current target property,
        i.e. a Boolean expression using names inserted elsewhere in this schema definition. */
    static void setRequiredIf(const char* expression);

    /** This function sets the value of the 'insert' attribute of the current target property, i.e.
        a conditional value expression providing names inserted when a value is entered for the
        property. */
    static void setInsert(const char* expression);

    /** This function sets the default value for the property in case the property is missing, in
        the form of a conditional value expression, which is evaluated against the names inserted
        elsewhere in this schema definition. Each value in the conditional expression must have a
        format compatible with the particular property type. If the string is empty, there is no
        default value. */
    static void setDefaultValue(const char* value);

    /** This function sets the minimum value for the property, in a format compatible with the
        particular property type. If the string is empty, the minimum value is determined by the
        implementation of the property type. */
    static void setMinValue(const char* value);

    /** This function sets the maximum value for the property, in a format compatible with the
        particular property type. If the string is empty, the maximum value is determined by the
        implementation of the property type. */
    static void setMaxValue(const char* value);

    /** This function sets the name of the physical quantity represented by this property. This
        must match one of the quantity names loaded into this schema via the addUnitDef() function
        and determines the allowed and default units for the property values. If the string is
        empty, the property values are dimensionless. */
    static void setQuantity(const char* value);

    /** This function sets the name of the base type for the instances of the current target
        property. This must match one of the type names defined in this schema. This information is
        relevant only for compound properties (i.e. properties containing other items of some
        type), and for those properties it should not be left empty. */
    static void setBase(const char* type);

    // ================== Obtaining a schema definition ==================

    /** This function returns a pointer to the schema definition with the specified name. Ownership
        remains with the registry. If there is no schema definition with the specified name, the
        function throws an error. */
    static const SchemaDef* getSchemaDef(string name);
};

////////////////////////////////////////////////////////////////////

#endif
